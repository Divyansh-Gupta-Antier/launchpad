// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`API snapshots Api of Launchpad 1`] = `
{
  "contractName": "Launchpad",
  "contractVersion": "?.?.?",
  "methods": [
    {
      "description": "Evaluate a batch of transactions Transaction is read only (evaluate). Allowed roles: EVALUATE.",
      "dtoSchema": {
        "properties": {
          "operations": {
            "items": {
              "properties": {
                "dto": {
                  "minLength": 1,
                  "properties": {
                    "prefix": {
                      "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signature": {
                      "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerAddress": {
                      "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerPublicKey": {
                      "description": "Public key of the user who signed the DTO.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signing": {
                      "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                      "enum": [
                        "ETH",
                        "TON",
                      ],
                      "type": "string",
                    },
                    "uniqueKey": {
                      "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                      "minLength": 1,
                      "type": "string",
                    },
                  },
                  "type": "object",
                },
                "method": {
                  "minLength": 1,
                  "type": "string",
                },
                "prefix": {
                  "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                  "minLength": 1,
                  "type": "string",
                },
                "signature": {
                  "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                  "minLength": 1,
                  "type": "string",
                },
                "signerAddress": {
                  "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                  "minLength": 1,
                  "type": "string",
                },
                "signerPublicKey": {
                  "description": "Public key of the user who signed the DTO.",
                  "minLength": 1,
                  "type": "string",
                },
                "signing": {
                  "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                  "enum": [
                    "ETH",
                    "TON",
                  ],
                  "type": "string",
                },
                "uniqueKey": {
                  "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "method",
                "dto",
              ],
              "type": "object",
            },
            "maxItems": 1000,
            "minItems": 1,
            "type": "array",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "writesLimit": {
            "description": "Soft limit of keys written to chain in a batch, excluding deletes. If the limit is exceeded, all subsequent operations in batch fail. Typically it is safe to repeat failed operations in the next batch. Default: 10000. Max: 100000.",
            "maximum": 100000,
            "minimum": 1,
            "type": "number",
          },
        },
        "required": [
          "operations",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "BatchEvaluate",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": "Submit a batch of transactionsSubmit a batch of transactions Allowed roles: SUBMIT. Allowed orgs: CuratorOrg.",
      "dtoSchema": {
        "properties": {
          "operations": {
            "items": {
              "properties": {
                "dto": {
                  "minLength": 1,
                  "properties": {
                    "prefix": {
                      "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signature": {
                      "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerAddress": {
                      "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerPublicKey": {
                      "description": "Public key of the user who signed the DTO.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signing": {
                      "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                      "enum": [
                        "ETH",
                        "TON",
                      ],
                      "type": "string",
                    },
                    "uniqueKey": {
                      "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                      "minLength": 1,
                      "type": "string",
                    },
                  },
                  "type": "object",
                },
                "method": {
                  "minLength": 1,
                  "type": "string",
                },
                "prefix": {
                  "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                  "minLength": 1,
                  "type": "string",
                },
                "signature": {
                  "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                  "minLength": 1,
                  "type": "string",
                },
                "signerAddress": {
                  "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                  "minLength": 1,
                  "type": "string",
                },
                "signerPublicKey": {
                  "description": "Public key of the user who signed the DTO.",
                  "minLength": 1,
                  "type": "string",
                },
                "signing": {
                  "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                  "enum": [
                    "ETH",
                    "TON",
                  ],
                  "type": "string",
                },
                "uniqueKey": {
                  "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "method",
                "dto",
              ],
              "type": "object",
            },
            "maxItems": 1000,
            "minItems": 1,
            "type": "array",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "writesLimit": {
            "description": "Soft limit of keys written to chain in a batch, excluding deletes. If the limit is exceeded, all subsequent operations in batch fail. Typically it is safe to repeat failed operations in the next batch. Default: 10000. Max: 100000.",
            "maximum": 100000,
            "minimum": 1,
            "type": "number",
          },
        },
        "required": [
          "operations",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "BatchSubmit",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": " Allowed roles: SUBMIT.",
      "dtoSchema": {
        "properties": {
          "expectedNativeToken": {
            "description": "Number provided as a string.",
            "type": "string",
          },
          "extraFees": {
            "properties": {
              "maxAcceptableReverseBondingCurveFee": {
                "description": "Number provided as a string.",
                "type": "string",
              },
            },
            "type": "object",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "tokenQuantity": {
            "description": "Number provided as a string.",
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "vaultAddress": {
            "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "vaultAddress",
          "tokenQuantity",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "BuyExactToken",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "functionName": {
                "minLength": 1,
                "type": "string",
              },
              "inputQuantity": {
                "minLength": 1,
                "type": "string",
              },
              "isFinalized": {
                "minLength": 1,
                "type": "string",
              },
              "nativeTokenAmount": {},
              "nativeTokenBalance": {},
              "outputQuantity": {
                "minLength": 1,
                "type": "string",
              },
              "tokenBalance": {},
              "tokenName": {
                "minLength": 1,
                "type": "string",
              },
              "tokenQuantity": {},
              "tradeType": {
                "minLength": 1,
                "type": "string",
              },
              "userAddress": {
                "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                "minLength": 1,
                "type": "string",
              },
              "vaultAddress": {
                "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "inputQuantity",
              "outputQuantity",
              "tokenName",
              "tradeType",
              "vaultAddress",
              "userAddress",
              "isFinalized",
              "functionName",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": " Allowed roles: SUBMIT.",
      "dtoSchema": {
        "properties": {
          "expectedToken": {
            "description": "Number provided as a string.",
            "type": "string",
          },
          "extraFees": {
            "properties": {
              "maxAcceptableReverseBondingCurveFee": {
                "description": "Number provided as a string.",
                "type": "string",
              },
            },
            "type": "object",
          },
          "nativeTokenQuantity": {
            "description": "Number provided as a string.",
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "vaultAddress": {
            "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "vaultAddress",
          "nativeTokenQuantity",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "BuyWithNative",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "functionName": {
                "minLength": 1,
                "type": "string",
              },
              "inputQuantity": {
                "minLength": 1,
                "type": "string",
              },
              "isFinalized": {
                "minLength": 1,
                "type": "string",
              },
              "nativeTokenAmount": {},
              "nativeTokenBalance": {},
              "outputQuantity": {
                "minLength": 1,
                "type": "string",
              },
              "tokenBalance": {},
              "tokenName": {
                "minLength": 1,
                "type": "string",
              },
              "tokenQuantity": {},
              "tradeType": {
                "minLength": 1,
                "type": "string",
              },
              "userAddress": {
                "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                "minLength": 1,
                "type": "string",
              },
              "vaultAddress": {
                "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "inputQuantity",
              "outputQuantity",
              "tokenName",
              "tradeType",
              "vaultAddress",
              "userAddress",
              "isFinalized",
              "functionName",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": " Transaction is read only (evaluate). Allowed roles: EVALUATE.",
      "dtoSchema": {
        "properties": {
          "nativeTokenQuantity": {
            "description": "Number provided as a string.",
            "minLength": 1,
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "nativeTokenQuantity",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "CalculatePreMintTokens",
      "responseSchema": {
        "properties": {
          "Data": {},
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": " Transaction is read only (evaluate). Allowed roles: EVALUATE.",
      "dtoSchema": {
        "properties": {
          "expectedToken": {
            "description": "Number provided as a string.",
            "type": "string",
          },
          "extraFees": {
            "properties": {
              "maxAcceptableReverseBondingCurveFee": {
                "description": "Number provided as a string.",
                "type": "string",
              },
            },
            "type": "object",
          },
          "nativeTokenQuantity": {
            "description": "Number provided as a string.",
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "vaultAddress": {
            "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "vaultAddress",
          "nativeTokenQuantity",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "CallMemeTokenIn",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "calculatedQuantity": {
                "minLength": 1,
                "type": "string",
              },
              "extraFees": {
                "items": {
                  "properties": {
                    "reverseBondingCurve": {
                      "minLength": 1,
                      "type": "string",
                    },
                  },
                  "required": [
                    "reverseBondingCurve",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
            },
            "required": [
              "calculatedQuantity",
              "extraFees",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": " Transaction is read only (evaluate). Allowed roles: EVALUATE.",
      "dtoSchema": {
        "properties": {
          "expectedToken": {
            "description": "Number provided as a string.",
            "type": "string",
          },
          "extraFees": {
            "properties": {
              "maxAcceptableReverseBondingCurveFee": {
                "description": "Number provided as a string.",
                "type": "string",
              },
            },
            "type": "object",
          },
          "nativeTokenQuantity": {
            "description": "Number provided as a string.",
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "vaultAddress": {
            "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "vaultAddress",
          "nativeTokenQuantity",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "CallMemeTokenOut",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "calculatedQuantity": {
                "minLength": 1,
                "type": "string",
              },
              "extraFees": {
                "items": {
                  "properties": {
                    "reverseBondingCurve": {
                      "minLength": 1,
                      "type": "string",
                    },
                  },
                  "required": [
                    "reverseBondingCurve",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
            },
            "required": [
              "calculatedQuantity",
              "extraFees",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": " Transaction is read only (evaluate). Allowed roles: EVALUATE.",
      "dtoSchema": {
        "properties": {
          "expectedNativeToken": {
            "description": "Number provided as a string.",
            "type": "string",
          },
          "extraFees": {
            "properties": {
              "maxAcceptableReverseBondingCurveFee": {
                "description": "Number provided as a string.",
                "type": "string",
              },
            },
            "type": "object",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "tokenQuantity": {
            "description": "Number provided as a string.",
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "vaultAddress": {
            "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "vaultAddress",
          "tokenQuantity",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "CallNativeTokenIn",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "calculatedQuantity": {
                "minLength": 1,
                "type": "string",
              },
              "extraFees": {
                "items": {
                  "properties": {
                    "reverseBondingCurve": {
                      "minLength": 1,
                      "type": "string",
                    },
                  },
                  "required": [
                    "reverseBondingCurve",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
            },
            "required": [
              "calculatedQuantity",
              "extraFees",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": " Transaction is read only (evaluate). Allowed roles: EVALUATE.",
      "dtoSchema": {
        "properties": {
          "expectedNativeToken": {
            "description": "Number provided as a string.",
            "type": "string",
          },
          "extraFees": {
            "properties": {
              "maxAcceptableReverseBondingCurveFee": {
                "description": "Number provided as a string.",
                "type": "string",
              },
            },
            "type": "object",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "tokenQuantity": {
            "description": "Number provided as a string.",
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "vaultAddress": {
            "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "vaultAddress",
          "tokenQuantity",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "CallNativeTokenOut",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "calculatedQuantity": {
                "minLength": 1,
                "type": "string",
              },
              "extraFees": {
                "items": {
                  "properties": {
                    "reverseBondingCurve": {
                      "minLength": 1,
                      "type": "string",
                    },
                  },
                  "required": [
                    "reverseBondingCurve",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
            },
            "required": [
              "calculatedQuantity",
              "extraFees",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": " Allowed roles: SUBMIT. Allowed orgs: CuratorOrg.",
      "dtoSchema": {
        "properties": {
          "newAuthorities": {
            "items": {
              "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
              "type": "string",
            },
            "type": "array",
          },
          "newPlatformFeeAddress": {
            "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "type": "object",
      },
      "isWrite": true,
      "methodName": "ConfigureLaunchpadFeeAddress",
      "responseSchema": {
        "properties": {
          "Data": {
            "description": "Defines the platform fee address and authorized owners for modification.",
            "properties": {
              "authorities": {
                "items": {
                  "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                  "type": "string",
                },
                "minItems": 1,
                "type": "array",
              },
              "feeAddress": {
                "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "feeAddress",
              "authorities",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": " Allowed roles: SUBMIT.",
      "dtoSchema": {
        "properties": {
          "preBuyQuantity": {
            "description": "Number provided as a string.",
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "reverseBondingCurveConfiguration": {
            "properties": {
              "maxFeePortion": {
                "description": "Number provided as a string.",
                "type": "string",
              },
              "minFeePortion": {
                "description": "Number provided as a string.",
                "type": "string",
              },
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "signing": {
                "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                "enum": [
                  "ETH",
                  "TON",
                ],
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "minFeePortion",
              "maxFeePortion",
            ],
            "type": "object",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "telegramUrl": {
            "type": "string",
          },
          "tokenCategory": {
            "minLength": 1,
            "type": "string",
          },
          "tokenCollection": {
            "minLength": 1,
            "type": "string",
          },
          "tokenDescription": {
            "minLength": 1,
            "type": "string",
          },
          "tokenImage": {
            "minLength": 1,
            "type": "string",
          },
          "tokenName": {
            "minLength": 1,
            "type": "string",
          },
          "tokenSymbol": {
            "minLength": 1,
            "type": "string",
          },
          "twitterUrl": {
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "websiteUrl": {
            "type": "string",
          },
        },
        "required": [
          "tokenName",
          "tokenSymbol",
          "tokenDescription",
          "tokenCollection",
          "tokenCategory",
          "tokenImage",
          "preBuyQuantity",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "CreateSale",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "creatorAddress": {
                "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                "minLength": 1,
                "type": "string",
              },
              "description": {
                "minLength": 1,
                "type": "string",
              },
              "functionName": {
                "minLength": 1,
                "type": "string",
              },
              "image": {
                "minLength": 1,
                "type": "string",
              },
              "initialBuyQuantity": {
                "minLength": 1,
                "type": "string",
              },
              "isFinalized": {
                "minLength": 1,
                "type": "string",
              },
              "reverseBondingCurveConfiguration": {
                "properties": {
                  "maxFeePortion": {
                    "description": "Number provided as a string.",
                    "type": "string",
                  },
                  "minFeePortion": {
                    "description": "Number provided as a string.",
                    "type": "string",
                  },
                  "prefix": {
                    "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                    "minLength": 1,
                    "type": "string",
                  },
                  "signature": {
                    "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                    "minLength": 1,
                    "type": "string",
                  },
                  "signerAddress": {
                    "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                    "minLength": 1,
                    "type": "string",
                  },
                  "signerPublicKey": {
                    "description": "Public key of the user who signed the DTO.",
                    "minLength": 1,
                    "type": "string",
                  },
                  "signing": {
                    "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                    "enum": [
                      "ETH",
                      "TON",
                    ],
                    "type": "string",
                  },
                  "uniqueKey": {
                    "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                    "minLength": 1,
                    "type": "string",
                  },
                },
                "required": [
                  "minFeePortion",
                  "maxFeePortion",
                ],
                "type": "object",
              },
              "symbol": {
                "minLength": 1,
                "type": "string",
              },
              "telegramUrl": {},
              "tokenName": {
                "minLength": 1,
                "type": "string",
              },
              "tokenStringKey": {
                "minLength": 1,
                "type": "string",
              },
              "twitterUrl": {},
              "vaultAddress": {
                "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                "minLength": 1,
                "type": "string",
              },
              "websiteUrl": {},
            },
            "required": [
              "image",
              "tokenName",
              "symbol",
              "description",
              "initialBuyQuantity",
              "vaultAddress",
              "creatorAddress",
              "collection",
              "category",
              "functionName",
              "isFinalized",
              "tokenStringKey",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": " Transaction is read only (evaluate). Allowed roles: EVALUATE.",
      "dtoSchema": {
        "properties": {
          "callerPublicKey": {
            "minLength": 1,
            "type": "string",
          },
          "dto": {
            "minLength": 1,
            "type": "string",
          },
          "method": {
            "minLength": 1,
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "method",
          "callerPublicKey",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "DryRun",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "signing": {
                "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                "enum": [
                  "ETH",
                  "TON",
                ],
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": " Transaction is read only (evaluate). Allowed roles: EVALUATE. Allowed orgs: CuratorOrg.",
      "dtoSchema": {
        "properties": {
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "type": "object",
      },
      "isWrite": false,
      "methodName": "FetchLaunchpadFeeConfig",
      "responseSchema": {
        "properties": {
          "Data": {
            "description": "Defines the platform fee address and authorized owners for modification.",
            "properties": {
              "authorities": {
                "items": {
                  "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                  "type": "string",
                },
                "minItems": 1,
                "type": "array",
              },
              "feeAddress": {
                "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "feeAddress",
              "authorities",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": " Transaction is read only (evaluate). Allowed roles: EVALUATE.",
      "dtoSchema": {
        "properties": {
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "vaultAddress": {
            "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "vaultAddress",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "FetchSaleDetails",
      "responseSchema": {
        "properties": {
          "Data": {
            "description": "Represents a launchpad sale, defining token quantities, pricing, and sale operations.",
            "properties": {
              "basePrice": {
                "description": "Number provided as a string.",
                "type": "string",
              },
              "euler": {
                "description": "Number provided as a string.",
                "type": "string",
              },
              "exponentFactor": {
                "description": "Number provided as a string.",
                "type": "string",
              },
              "maxSupply": {
                "description": "Number provided as a string.",
                "type": "string",
              },
              "nativeToken": {
                "minLength": 1,
                "type": "string",
              },
              "nativeTokenQuantity": {
                "minLength": 1,
                "type": "string",
              },
              "reverseBondingCurveConfiguration": {
                "properties": {
                  "maxFeePortion": {
                    "description": "Number provided as a string.",
                    "type": "string",
                  },
                  "minFeePortion": {
                    "description": "Number provided as a string.",
                    "type": "string",
                  },
                },
                "required": [
                  "minFeePortion",
                  "maxFeePortion",
                ],
                "type": "object",
              },
              "saleOwner": {
                "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                "minLength": 1,
                "type": "string",
              },
              "saleStatus": {
                "enum": [
                  "Finished",
                  "Ongoing",
                ],
                "minLength": 1,
                "type": "string",
              },
              "sellingToken": {
                "minLength": 1,
                "type": "string",
              },
              "sellingTokenQuantity": {
                "minLength": 1,
                "type": "string",
              },
              "vaultAddress": {
                "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "vaultAddress",
              "saleStatus",
              "sellingToken",
              "nativeToken",
              "sellingTokenQuantity",
              "nativeTokenQuantity",
              "saleOwner",
              "basePrice",
              "exponentFactor",
              "maxSupply",
              "euler",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": " Allowed roles: SUBMIT. Allowed orgs: CuratorOrg.",
      "dtoSchema": {
        "properties": {
          "ownerFeePercentage": {
            "maximum": 1,
            "minimum": 0,
            "type": "number",
          },
          "platformFeePercentage": {
            "maximum": 1,
            "minimum": 0,
            "type": "number",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "platformFeePercentage",
          "ownerFeePercentage",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "FinalizeTokenAllocation",
      "responseSchema": {
        "properties": {
          "Data": {
            "description": "Defines the platform fee and owner allocation percentages.",
            "properties": {
              "ownerAllocationPercentage": {
                "maximum": 1,
                "minimum": 0,
                "type": "number",
              },
              "platformFeePercentage": {
                "maximum": 1,
                "minimum": 0,
                "type": "number",
              },
            },
            "required": [
              "platformFeePercentage",
              "ownerAllocationPercentage",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "deprecated": true,
      "description": "Gets the contract version. Deprecated. Use GetContractVersion instead. Transaction is read only (evaluate). Allowed roles: EVALUATE.",
      "isWrite": false,
      "methodName": "GetChaincodeVersion",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "string",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": " Transaction is read only (evaluate). Allowed roles: EVALUATE.",
      "isWrite": false,
      "methodName": "GetContractAPI",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": " Transaction is read only (evaluate). Allowed roles: EVALUATE.",
      "isWrite": false,
      "methodName": "GetContractVersion",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "string",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": " Transaction is read only (evaluate). Allowed roles: EVALUATE.",
      "dtoSchema": {
        "properties": {
          "objectId": {
            "minLength": 1,
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "objectId",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "GetObjectByKey",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": " Transaction is read only (evaluate). Allowed roles: EVALUATE.",
      "dtoSchema": {
        "properties": {
          "objectId": {
            "minLength": 1,
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "objectId",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "GetObjectHistory",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": " Allowed roles: SUBMIT.",
      "dtoSchema": {
        "properties": {
          "expectedNativeToken": {
            "description": "Number provided as a string.",
            "type": "string",
          },
          "extraFees": {
            "properties": {
              "maxAcceptableReverseBondingCurveFee": {
                "description": "Number provided as a string.",
                "type": "string",
              },
            },
            "type": "object",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "tokenQuantity": {
            "description": "Number provided as a string.",
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "vaultAddress": {
            "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "vaultAddress",
          "tokenQuantity",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "SellExactToken",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "functionName": {
                "minLength": 1,
                "type": "string",
              },
              "inputQuantity": {
                "minLength": 1,
                "type": "string",
              },
              "isFinalized": {
                "minLength": 1,
                "type": "string",
              },
              "nativeTokenAmount": {},
              "nativeTokenBalance": {},
              "outputQuantity": {
                "minLength": 1,
                "type": "string",
              },
              "tokenBalance": {},
              "tokenName": {
                "minLength": 1,
                "type": "string",
              },
              "tokenQuantity": {},
              "tradeType": {
                "minLength": 1,
                "type": "string",
              },
              "userAddress": {
                "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                "minLength": 1,
                "type": "string",
              },
              "vaultAddress": {
                "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "inputQuantity",
              "outputQuantity",
              "tokenName",
              "tradeType",
              "vaultAddress",
              "userAddress",
              "isFinalized",
              "functionName",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": " Allowed roles: SUBMIT.",
      "dtoSchema": {
        "properties": {
          "expectedToken": {
            "description": "Number provided as a string.",
            "type": "string",
          },
          "extraFees": {
            "properties": {
              "maxAcceptableReverseBondingCurveFee": {
                "description": "Number provided as a string.",
                "type": "string",
              },
            },
            "type": "object",
          },
          "nativeTokenQuantity": {
            "description": "Number provided as a string.",
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "vaultAddress": {
            "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "vaultAddress",
          "nativeTokenQuantity",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "SellWithNative",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "functionName": {
                "minLength": 1,
                "type": "string",
              },
              "inputQuantity": {
                "minLength": 1,
                "type": "string",
              },
              "isFinalized": {
                "minLength": 1,
                "type": "string",
              },
              "nativeTokenAmount": {},
              "nativeTokenBalance": {},
              "outputQuantity": {
                "minLength": 1,
                "type": "string",
              },
              "tokenBalance": {},
              "tokenName": {
                "minLength": 1,
                "type": "string",
              },
              "tokenQuantity": {},
              "tradeType": {
                "minLength": 1,
                "type": "string",
              },
              "userAddress": {
                "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                "minLength": 1,
                "type": "string",
              },
              "vaultAddress": {
                "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "inputQuantity",
              "outputQuantity",
              "tokenName",
              "tradeType",
              "vaultAddress",
              "userAddress",
              "isFinalized",
              "functionName",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
  ],
}
`;
